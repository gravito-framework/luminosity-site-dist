<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    

    
    <link rel="stylesheet" href="/static/build/assets/app.css">
    <script type="module" src="/static/build/assets/app.js"></script>
    
<title>Performance Benchmark - Luminosity Docs</title>
<meta name="description" content="Documentation for Performance Benchmark in Luminosity SEO Engine.">
<link rel="canonical" href="https://lux.gravito.dev/docs/benchmark">
<meta property="og:title" content="Performance Benchmark - Luminosity Docs">
<meta property="og:type" content="website">
<meta property="og:url" content="https://lux.gravito.dev/docs/benchmark">
<meta property="og:description" content="Documentation for Performance Benchmark in Luminosity SEO Engine.">
<meta property="og:image" content="https://lux.gravito.dev/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Performance Benchmark - Luminosity Docs">
<meta name="twitter:description" content="Documentation for Performance Benchmark in Luminosity SEO Engine.">
<meta name="twitter:image" content="https://lux.gravito.dev/og-image.png">
</head>

<body class="bg-black">
    <div id="app" data-page='{"component":"Docs","props":{"title":"Performance Benchmark","content":"&lt;h1&gt;ðŸ”¥ Performance Benchmark&lt;/h1&gt;\n&lt;p&gt;Luminosity is engineered for &lt;strong&gt;extreme scale&lt;/strong&gt;. We don&amp;#39;t just claim performance; we prove it.\nUsing our unique &lt;strong&gt;Streaming Architecture&lt;/strong&gt;, Luminosity can generate sitemaps for millions of URLs with a constant, tiny memory footprint.&lt;/p&gt;\n&lt;h2&gt;The 1 Million URL Challenge&lt;/h2&gt;\n&lt;p&gt;Generating a sitemap for 1,000,000 pages is a common bottleneck for large applications.\nTraditional solutions often load all data into memory, causing Node.js processes to crash (Heap Out of Memory) or requiring expensive, high-memory servers.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Luminosity solves this with:&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;Async Iterators&lt;/strong&gt;: Streaming data directly from the database to the XML writer.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Backpressure Handling&lt;/strong&gt;: Respecting the I/O capacity of the disk.&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Automatic Sharding&lt;/strong&gt;: Splitting files automatically when they hit the 50,000 URL limit.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2&gt;Benchmark Results&lt;/h2&gt;\n&lt;p&gt;We ran a controlled test generating a Sitemap Index for &lt;strong&gt;1,000,000 URLs&lt;/strong&gt;.&lt;/p&gt;\n&lt;h3&gt;Environment&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Hardware&lt;/strong&gt;: MacBook Pro (M2 Pro)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Runtime&lt;/strong&gt;: Bun v1.1&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Database&lt;/strong&gt;: SQLite (Simulating 1M Product Rows)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;Metrics&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th align=\&quot;left\&quot;&gt;Metric&lt;/th&gt;\n&lt;th align=\&quot;left\&quot;&gt;Result&lt;/th&gt;\n&lt;th align=\&quot;left\&quot;&gt;Note&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;Total URLs&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;1,000,000&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;Full sitemap index generation&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;Time Elapsed&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;~14.2s&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;End-to-end processing&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;Throughput&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;~70,000 URLs/sec&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;Extremely fast processing&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;Peak Memory&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;84 MB&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;Constant Heap Usage&lt;/strong&gt; ðŸ¤¯&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: The most impressive metric is the memory usage. It stays flat regardless of whether you process 10k or 10M URLs.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;Implementation Details&lt;/h2&gt;\n&lt;p&gt;Here is the core logic used in our benchmark. Notice the use of &lt;code&gt;yield&lt;/code&gt; to stream data one row at a time.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;language-typescript\&quot;&gt;// Example using @gravito/luminosity\nconst sitemap = new SeoEngine({\n  baseUrl: &amp;#39;https://store.example.com&amp;#39;,\n  mode: &amp;#39;dynamic&amp;#39;, // or incremental\n  resolvers: [\n    {\n      async *getEntries() {\n        const stmt = db.prepare(&amp;#39;SELECT slug, updated_at FROM products&amp;#39;)\n        \n        // Iterate row by row - never load 1M rows into array!\n        for (const row of stmt.iterate()) {\n          yield {\n            url: `/products/${row.slug}`,\n            lastmod: row.updated_at,\n            changefreq: &amp;#39;daily&amp;#39;\n          }\n        }\n      }\n    }\n  ]\n})\n\nawait sitemap.init()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;Reproduce It&lt;/h2&gt;\n&lt;p&gt;You can run this benchmark yourself. The code is available in our &lt;a href=\&quot;https://github.com/gravito-framework/gravito/tree/main/examples/luminosity-benchmark\&quot;&gt;GitHub Repository&lt;/a&gt;.&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Clone the repository.&lt;/li&gt;\n&lt;li&gt;Navigate to &lt;code&gt;examples/luminosity-benchmark&lt;/code&gt;.&lt;/li&gt;\n&lt;li&gt;Run seeds and benchmark:&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&quot;language-bash\&quot;&gt;bun install\nbun run seed      # Generates 1M records\nbun run benchmark # Fires the engine\n&lt;/code&gt;&lt;/pre&gt;\n","toc":[],"sidebar":[{"title":"Guide","items":[{"title":"Framework Integrations","href":"/docs/frameworks"},{"title":"CLI Reference","href":"/docs/cli"},{"title":"Usage Examples","href":"/docs/examples"},{"title":"Performance Benchmark","href":"/docs/benchmark"},{"title":"introduction","href":"/docs/introduction"},{"title":"getting-started","href":"/docs/getting-started"}]}],"currentPath":"/docs/benchmark","locale":"en"},"url":"/docs/benchmark","version":"1.0.0"}'></div>
</body>

</html>