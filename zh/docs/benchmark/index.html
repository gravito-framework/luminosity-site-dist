<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="icon" href="/favicon.ico">

    
    <link rel="stylesheet" href="/static/build/assets/app.css">
    <script type="module" src="/static/build/assets/app.js"></script>
    
<title>效能基準測試 - Luminosity 指南</title>
<meta name="description" content="Documentation for 效能基準測試 in Luminosity SEO Engine.">
<link rel="canonical" href="https://lux.gravito.dev/zh/docs/benchmark">
<meta property="og:title" content="效能基準測試 - Luminosity 指南">
<meta property="og:type" content="website">
<meta property="og:url" content="https://lux.gravito.dev/zh/docs/benchmark">
<meta property="og:description" content="Documentation for 效能基準測試 in Luminosity SEO Engine.">
<meta property="og:image" content="https://lux.gravito.dev/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="效能基準測試 - Luminosity 指南">
<meta name="twitter:description" content="Documentation for 效能基準測試 in Luminosity SEO Engine.">
<meta name="twitter:image" content="https://lux.gravito.dev/og-image.png">
</head>

<body class="bg-black">
    <div id="app" data-page='{"component":"Docs","props":{"title":"效能基準測試","content":"&lt;h1&gt;🔥 效能基準測試實證 (Benchmark)&lt;/h1&gt;\n&lt;p&gt;Luminosity 專為 &lt;strong&gt;極大規模 (Extreme Scale)&lt;/strong&gt; 而設計。我們不只空談效能，我們用資料證明。\n透過獨特的 &lt;strong&gt;串流架構 (Streaming Architecture)&lt;/strong&gt;，Luminosity 能夠以極低的固定記憶體消耗，為數百萬個 URL 產生 Sitemap。&lt;/p&gt;\n&lt;h2&gt;100 萬個 URL 的挑戰&lt;/h2&gt;\n&lt;p&gt;為 1,000,000 個頁面產生 Sitemap 是大型應用常見的效能瓶頸。\n傳統解決方案通常將所有資料載入記憶體，導致 Node.js 進程崩潰 (Heap Out of Memory)，或需要昂貴的高記憶體伺服器。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Luminosity 的解決方案：&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;非同步迭代器 (Async Iterators)&lt;/strong&gt;：從資料庫直接串流資料到 XML 寫入器。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;背壓處理 (Backpressure)&lt;/strong&gt;：尊重磁碟 I/O 的寫入能力。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;自動分片 (Automatic Sharding)&lt;/strong&gt;：當達到 50,000 URL 限制時自動分割檔案。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2&gt;測試結果&lt;/h2&gt;\n&lt;p&gt;我們進行了一項受控測試，為 &lt;strong&gt;1,000,000 個 URL&lt;/strong&gt; 產生 Sitemap 索引。&lt;/p&gt;\n&lt;h3&gt;測試環境&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;硬體&lt;/strong&gt;: MacBook Pro (M2 Pro)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Runtime&lt;/strong&gt;: Bun v1.1&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;資料庫&lt;/strong&gt;: SQLite (模擬 100 萬筆產品資料)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3&gt;關鍵指標&lt;/h3&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th align=\&quot;left\&quot;&gt;指標&lt;/th&gt;\n&lt;th align=\&quot;left\&quot;&gt;結果&lt;/th&gt;\n&lt;th align=\&quot;left\&quot;&gt;備註&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;總 URL 數&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;1,000,000&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;完整的 Sitemap 索引產生&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;耗時&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;~14.2s&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;端到端處理時間&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;~70,000 URLs/sec&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;極速處理能力&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;記憶體峰值&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;84 MB&lt;/strong&gt;&lt;/td&gt;\n&lt;td align=\&quot;left\&quot;&gt;&lt;strong&gt;固定 Heap 用量 (Constant Usage)&lt;/strong&gt; 🤯&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：最令人印象深刻的是記憶體用量。無論處理 1 萬還是 1000 萬個 URL，記憶體佔用都保持平穩。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2&gt;實作細節&lt;/h2&gt;\n&lt;p&gt;以下是我們 Benchmark 中使用的核心邏輯。請注意 &lt;code&gt;yield&lt;/code&gt; 的使用，它確保了一次只處理一行資料。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&quot;language-typescript\&quot;&gt;// 使用 @gravito/luminosity 的範例\nconst sitemap = new SeoEngine({\n  baseUrl: &amp;#39;https://store.example.com&amp;#39;,\n  mode: &amp;#39;dynamic&amp;#39;, // 或 incremental\n  resolvers: [\n    {\n      async *getEntries() {\n        // 從資料庫獲取 Iterator\n        const stmt = db.prepare(&amp;#39;SELECT slug, updated_at FROM products&amp;#39;)\n        \n        // 逐行迭代 - 永遠不要把 100 萬行塞進陣列！\n        for (const row of stmt.iterate()) {\n          yield {\n            url: `/products/${row.slug}`,\n            lastmod: row.updated_at,\n            changefreq: &amp;#39;daily&amp;#39;\n          }\n        }\n      }\n    }\n  ]\n})\n\nawait sitemap.init()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2&gt;親自驗證&lt;/h2&gt;\n&lt;p&gt;您可以親自執行此基準測試。程式碼託管於我們的 &lt;a href=\&quot;https://github.com/gravito-framework/gravito/tree/main/examples/luminosity-benchmark\&quot;&gt;GitHub Repository&lt;/a&gt;。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Clone 專案庫。&lt;/li&gt;\n&lt;li&gt;進入 &lt;code&gt;examples/luminosity-benchmark&lt;/code&gt; 目錄。&lt;/li&gt;\n&lt;li&gt;執行種子產生與測試：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&quot;language-bash\&quot;&gt;bun install\nbun run seed      # 產生 100 萬筆測試資料\nbun run benchmark # 啟動引擎\n&lt;/code&gt;&lt;/pre&gt;\n","toc":[],"sidebar":[{"title":"指南","items":[{"title":"介紹","href":"/zh/docs/introduction"},{"title":"快速開始","href":"/zh/docs/getting-started"},{"title":"框架整合","href":"/zh/docs/frameworks"},{"title":"CLI 命令列工具","href":"/zh/docs/cli"},{"title":"使用範例","href":"/zh/docs/examples"},{"title":"效能基準測試","href":"/zh/docs/benchmark"}]}],"currentPath":"/zh/docs/benchmark","locale":"zh"},"url":"/zh/docs/benchmark","version":"1.0.0"}'></div>
</body>

</html>